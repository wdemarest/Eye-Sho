<!DOCTYPE html>
<html>
  <head>
    <title>Eye Sho</title>
    <style>
    </style>
  </head>
  <body>
    <canvas id="canvas" width="1200" height="1200"></canvas>

    <script src="/socket.io/socket.io.js"></script>
    <script>
      const socket = io();

      let imagesAllLoaded = false;

      let data = {};

      socket.on('initialInfo', (initalInfo) => {
        console.log('initial info recieved');
        data.pieces = initalInfo.pieceData;

        gameState.board = initalInfo.board;
      });

      socket.on('pieceList', (pieces) => {
        gameState.pieces = pieces;

        view.render();
      });

      //images
      let piecesImg = new Image();
      piecesImg.src = 'http://localhost:25565/img/Pieces.png';

      //make sure all images are loaded
      piecesImg.onload = () => {
        imagesAllLoaded = true;
        
        view.render();
      }

      class GameState {
        constructor() {
          this.setup = data.setup;
          this.board = data.board;
          this.pieces = [];
        }
      }

      //SIM
      class Sim {
        constructor(){
        }
      }

      //VIEW

      class View {
        constructor(){
          this.canvas = document.getElementById('canvas');
          this.ctx = this.canvas.getContext('2d');


          this.boardCenter = {x: 600, y: 600};
          this.boardDrawRadius = 400;
          this.boardDrawMargin = 0;


          this.pieceResolution = 500;

          this.pieceDrawSize = this.boardDrawRadius / 5;
        }

        render(){
          if(!imagesAllLoaded){
            return;
          }

          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

          if(gameState.board){
            this.renderBoard(gameState.board);
          }

          if(gameState.pieces.length > 0){
            this.renderPieces(gameState.pieces);
          }
        }

        renderBoard(){
          if(!this.degreesPerRadial){
            this.degreesPerRadial = 360/gameState.board.radialCount;
            this.distBetweenCircles = (this.boardDrawRadius-this.boardDrawMargin) / gameState.board.circleCount;
          }

          this.renderBoardNodes();
          this.renderBoardLines();
        }

        renderBoardNodes(){
          gameState.board.nodes.forEach(node => {
            this.ctx.strokeStyle = 'white';
            this.drawCircleByCR(node.c, node.r, 10);
          });
        }

        renderBoardLines(){
          gameState.board.radialConnections.forEach(connection => {
            let start = this.CRToXY(connection[0].c, connection[0].r);
            let end = this.CRToXY(connection[1].c, connection[1].r);

            this.ctx.beginPath();
            this.ctx.moveTo(start.x, start.y);
            this.ctx.lineTo(end.x, end.y);
            this.ctx.stroke();
          });

          gameState.board.circleConnections.forEach(connection => {
            let radius = this.CToDistFromCenter(connection[0].c);

            let angle1 = this.RToAngle(connection[0].r);
            let angle2 = this.RToAngle(connection[1].r);

            this.ctx.beginPath();
            this.ctx.arc(this.boardCenter.x, this.boardCenter.y, radius, angle1, angle2);
            this.ctx.stroke();
          });
        }

        renderPieces(pieces){

          pieces.forEach(piece => {
            if(piece.onBoard !== false){
              let pos = this.CRToXY(piece.c, piece.r);
              this.drawPiece(piece.player, piece.type, pos);
            }
          });

        }

        drawPiece(player, type, pos){
          let drawX = pos.x - this.pieceDrawSize/2;
          let drawY = pos.y - this.pieceDrawSize/2;

          let sourceX = data.pieces[type].numInTilesheet * this.pieceResolution;
          let sourceY = (1-player) * this.pieceResolution;
          
          this.ctx.drawImage(piecesImg, sourceX, sourceY, this.pieceResolution, this.pieceResolution, drawX, drawY, this.pieceDrawSize, this.pieceDrawSize);
        }



        drawCircleByCR(c, r, radius){
          this.drawCircle(this.CRToXY(c, r), radius);
          
        }

        drawCircle(center, radius){
          this.ctx.beginPath();
          this.ctx.arc(center.x, center.y, radius, 0, 2 * Math.PI);
          this.ctx.stroke();
        }



        calcOffset(startingPos, angle, length){
          return {
            x: startingPos.x + length * Math.cos(angle * Math.PI / 180),
            y: startingPos.y + length * Math.sin(angle * Math.PI / 180)
          }
        }

        CToDistFromCenter(c){
          return this.distBetweenCircles * c;
        }

        RToAngle(r){
          return (this.degreesPerRadial * r)-90;
        }

        CRToXY(c, r){
          let distFromCenter = this.CToDistFromCenter(c);
          let angle = this.RToAngle(r)

          return {
            x: this.boardCenter.x + distFromCenter * Math.cos(angle * Math.PI / 180),
            y: this.boardCenter.y + distFromCenter * Math.sin(angle * Math.PI / 180)
          }
        }
      }

      const view = new View();
      const gameState = new GameState();

    </script>
  </body>
</html>